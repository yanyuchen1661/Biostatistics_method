## Macro Concepts
- Macros 
- Macro variables
  - Local
  - Global
- Before use macros you must have the MACRO system option turned on
```sas
PROC OPTIONS OPTION = MACRO; RUN;
```
## Substituting Text with Macro Variables
- %LET
```sas
%LET iterations = 10;
%LET country = New Zealand;
DO i = 1 to &iterations;
TITLE ”Addresses in &country”;
```
After being resolved by the macro processor, these statements would become
```sas
DO i = 1 to 10;
TITLE ”Addresses in New Zealand”;
```
## Marco code
### Creating Modular Code with Macros
```sas
* Macro to print 5 largest sales; %MACRO sample;
PROC SORT DATA = flowersales; BY DESCENDING Quantity;
PROC PRINT DATA = flowersales (OBS = 5); FORMAT SaleDate WORDDATE18.;
TITLE 'Five Largest Sales';
   %MEND sample;
* Read the flower sales data; DATA flowersales;
INFILE 'c:\MyRawData\TropicalSales.dat'; INPUT CustomerID $ @6 SaleDate MMDDYY10. @17
Variety $9. Quantity;
RUN;
   * Invoke the macro;
   %sample
   RUN;
```
### Adding Parameters to Macros
```sas
* Macro with parameters;
%MACRO select(customer=,sortvar=);
PROC SORT DATA = flowersales OUT = salesout; BY &sortvar;
WHERE CustomerID = ”&customer”; PROC PRINT DATA = salesout;
FORMAT SaleDate WORDDATE18.;
TITLE1 ”Orders for Customer Number &customer”; TITLE2 ”Sorted by &sortvar”;
   %MEND select;
* Read all the flower sales data; DATA flowersales;
INFILE ’c:\MyRawData\TropicalSales.dat’; INPUT CustomerID $ @6 SaleDate MMDDYY10. @17
Variety $9. Quantity;
RUN;
*Invoke the macro;
%select(customer = 356W, sortvar = Quantity) %select(customer = 240W, sortvar = Variety) RUN;
```
### Macros with Conditional Logic
You may be wondering why anyone needs these statements. Why not just use the standard IF-THEN? You may indeed use standard IF-THEN statements in your macros, but you will use them for different actions. %IF statements can contain actions that standard IF statements can’t contain, such as complete DATA or PROC steps and even other macro statements. The %IF-%THEN statements don’t appear in the standard SAS code generated by your macro. Remember you are writing a program that writes a program.
```sas
%IF condition %THEN action;
%ELSE %IF condition %THEN action; %ELSE action;
%IF condition %THEN %DO; SAS statements
%END;
```

### Data-Driven Programs with CALL SYMPUT
CALL SYMPUT is often used in IF-THEN statements such as this:
```sas
IF Age >= 18 THEN CALL SYMPUT(”status”, ”Adult”); ELSE CALL SYMPUT(”status”, ”Minor”);
```
These statements create a macro variable named &STATUS and assign to it a value of either Adult or Minor depending on the variable Age. The following CALL SYMPUT uses a variable as its value:
```sas
IF TotalSales > 1000000 THEN CALL SYMPUT(”bestseller”, BookTitle); 
```
This statement tells SAS to create a macro variable named &BESTSELLER which is equal to the
value of the variable BookTitle when TotalSales exceed 1,000,000.


```sas
* Read the raw data; DATA flowersales;
INFILE 'c:\MySASLib\TropicalSales.dat';
INPUT CustomerID $4. @6 SaleDate MMDDYY10. @17
Variety $9. Quantity; PROC SORT DATA = flowersales;
BY DESCENDING Quantity;
* Find biggest order and pass the customer id to a macro variable; DATA _NULL_;
SET flowersales;
IF _N_ = 1 THEN CALL SYMPUT(”selectedcustomer”,CustomerID); ELSE STOP;
PROC PRINT DATA = flowersales;
WHERE CustomerID = ”&selectedcustomer”;
FORMAT SaleDate WORDDATE18.;
TITLE ”Customer &selectedcustomer Had the Single Largest Order”;
RUN;
```

- This program has a lot of steps, but each step is fairly simple. The first DATA step reads the data from the raw data file. Then PROC SORT sorts the data by descending Quantity. That way, the largest single order will be the first observation in the newly sorted data set.
- The second DATA step then uses CALL SYMPUT to assign the value of the variable CustomerID to the macro variable &SELECTEDCUSTOMER when _N_ equals 1 (the first iteration of the DATA step). Since that is all we need from this DATA step, we can use the STOP statement to tell SAS to end this DATA step. The STOP statement is not necessary, but it is efficient because it prevents SAS from reading the remaining observations for no reason.
- When SAS reaches the PROC PRINT statement, SAS knows that the DATA step has ended so SAS executes the DATA step. At this point the macro variable &SELECTEDCUSTOMER has the value 356W (the customer ID with the largest single order) and can be used in the PROC PRINT.

## Debug the Macro Errors
### Quoting problems
- The macro processor doesn’t resolve macros inside single quotation marks. To get around this, use double quotation marks whenever you refer to a macro or macro variable and you want SAS to resolve it.
### System options for debugging macros
**MERROR** | NOMERROR when this option is on, SAS will issue a warning if you invoke a macro that SAS cannot find.
**SERROR** | NOSERROR when this option is on, SAS will issue a warning if you use a macro variable that SAS cannot find.

MLOGIC | **NOMLOGIC** when this option is on, SAS prints in your log details about the execution of macros.

MPRINT | **NOMPRINT** when this option is on, SAS prints in your log the standard SAS code generated by macros.

SYMBOLGEN | **NOSYMBOLGEN** when this option is on, SAS prints in your log the values of macro variables.

